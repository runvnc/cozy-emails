// Generated by CoffeeScript 1.9.1
var Account, AccountConfigError, Compiler, ImapPool, ImapReporter, Mailbox, Message, SMTPConnection, _, americano, async, log, nodemailer,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

americano = require(MODEL_MODULE);

module.exports = Account = americano.getModel('Account', {
  label: String,
  name: String,
  login: String,
  password: String,
  accountType: String,
  smtpServer: String,
  smtpPort: Number,
  smtpSSL: Boolean,
  smtpTLS: Boolean,
  imapServer: String,
  imapPort: Number,
  imapSSL: Boolean,
  imapTLS: Boolean,
  inboxMailbox: String,
  draftMailbox: String,
  sentMailbox: String,
  trashMailbox: String,
  junkMailbox: String,
  allMailbox: String,
  favorites: function(x) {
    return x;
  }
});

Mailbox = require('./mailbox');

Message = require('./message');

Compiler = require('nodemailer/src/compiler');

ImapPool = require('../imap/pool');

ImapReporter = require('../imap/reporter');

AccountConfigError = require('../utils/errors').AccountConfigError;

nodemailer = require('nodemailer');

SMTPConnection = require('nodemailer/node_modules/' + 'nodemailer-smtp-transport/node_modules/smtp-connection');

log = require('../utils/logging')({
  prefix: 'models:account'
});

_ = require('lodash');

async = require('async');

require('../utils/socket_handler').wrapModel(Account, 'account');

Account.prototype.doASAP = function(operation, callback) {
  return ImapPool.get(this.id).doASAP(operation, callback);
};

Account.prototype.isTest = function() {
  return this.accountType === 'TEST';
};

Account.prototype.isRefreshing = function() {
  return ImapPool.get(this.id).isRefreshing;
};

Account.prototype.setRefreshing = function(value) {
  return ImapPool.get(this.id).isRefreshing = value;
};

Account.refreshAllAccounts = function(limit, onlyFavorites, callback) {
  return Account.request('all', function(err, accounts) {
    if (err) {
      return callback(err);
    }
    return Account.refreshAccounts(accounts, limit, onlyFavorites, callback);
  });
};

Account.removeOrphansAndRefresh = function(limitByBox, onlyFavorites, callback) {
  return Account.request('all', function(err, accounts) {
    var existingAccountIDs;
    if (err) {
      return callback(err);
    }
    existingAccountIDs = accounts.map(function(account) {
      return account.id;
    });
    return Mailbox.removeOrphans(existingAccountIDs, function(err, existingMailboxIDs) {
      if (err) {
        return callback(err);
      }
      return Message.removeOrphans(existingMailboxIDs, function(err) {
        if (err) {
          return callback(err);
        }
        return Account.refreshAccounts(accounts, limitByBox, onlyFavorites, callback);
      });
    });
  });
};

Account.refreshAccounts = function(accounts, limitByBox, onlyFavorites, callback) {
  return async.eachSeries(accounts, function(account, cb) {
    log.debug("refreshing account " + account.label);
    if (account.isTest()) {
      return cb(null);
    }
    if (account.isRefreshing()) {
      return cb(null);
    }
    return account.imap_fetchMails(limitByBox, onlyFavorites, cb);
  }, callback);
};

Account.createIfValid = function(data, callback) {
  var account, toFetch;
  account = new Account(data);
  toFetch = null;
  return async.series([
    function(cb) {
      log.debug("create#testConnections");
      return account.testConnections(cb);
    }, function(cb) {
      log.debug("create#cozy");
      return Account.create(account, function(err, created) {
        if (err) {
          return cb(err);
        }
        account = created;
        return cb(null);
      });
    }, function(cb) {
      log.debug("create#refreshBoxes");
      return account.imap_refreshBoxes(function(err, boxes) {
        if (err) {
          return cb(err);
        }
        toFetch = boxes;
        return cb(null);
      });
    }, function(cb) {
      log.debug("create#scan");
      return account.imap_scanBoxesForSpecialUse(toFetch, cb);
    }
  ], function(err) {
    if (err) {
      return callback(err);
    }
    return callback(null, account);
  });
};

Account.checkParams = function(data, callback) {
  var account;
  account = new Account(data);
  return account.testConnections(callback);
};

Account.prototype.testConnections = function(callback) {
  if (this.isTest()) {
    return callback(null);
  }
  return this.testSMTPConnection((function(_this) {
    return function(err) {
      if (err) {
        return callback(err);
      }
      return ImapPool.test(_this, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null);
      });
    };
  })(this));
};

Account.prototype.forgetBox = function(boxid, callback) {
  var attribute, changes, i, len, ref;
  changes = {};
  ref = Object.keys(Mailbox.RFC6154);
  for (i = 0, len = ref.length; i < len; i++) {
    attribute = ref[i];
    if (this[attribute] === boxid) {
      changes[attribute] = null;
    }
  }
  if (indexOf.call(this.favorites, boxid) >= 0) {
    changes.favorites = _.without(this.favorites, boxid);
  }
  if (Object.keys(changes).length) {
    return this.updateAttributes(changes, callback);
  } else {
    return callback(null);
  }
};

Account.prototype.destroyEverything = function(callback) {
  return async.series([
    (function(_this) {
      return function(cb) {
        return _this.destroy(cb);
      };
    })(this), (function(_this) {
      return function(cb) {
        return Mailbox.destroyByAccount(_this.id, cb);
      };
    })(this), (function(_this) {
      return function(cb) {
        return Message.safeDestroyByAccountID(_this.id, cb);
      };
    })(this)
  ], callback);
};

Account.prototype.toClientObject = function(callback) {
  var rawObject;
  rawObject = this.toObject();
  if (rawObject.favorites == null) {
    rawObject.favorites = [];
  }
  return Mailbox.rawRequest('treeMap', {
    startkey: [this.id],
    endkey: [this.id, {}],
    include_docs: true
  }, function(err, rows) {
    if (err) {
      return callback(err);
    }
    rawObject.mailboxes = rows.map(function(row) {
      var base;
      if ((base = row.doc).id == null) {
        base.id = row.id;
      }
      return _.pick(row.doc, 'id', 'label', 'attribs', 'tree');
    });
    return Mailbox.getCounts(null, function(err, counts) {
      var box, count, i, len, ref;
      if (err) {
        return callback(err);
      }
      ref = rawObject.mailboxes;
      for (i = 0, len = ref.length; i < len; i++) {
        box = ref[i];
        count = counts[box.id] || {
          total: 0,
          unread: 0,
          recent: 0
        };
        box.nbTotal = count.total;
        box.nbUnread = count.unread;
        box.nbRecent = count.recent;
      }
      return callback(null, rawObject);
    });
  });
};

Account.clientList = function(callback) {
  return Account.request('all', function(err, accounts) {
    if (err) {
      return callback(err);
    }
    return async.map(accounts, function(account, cb) {
      return account.toClientObject(cb);
    }, callback);
  });
};

Account.prototype.imap_getBoxes = function(callback) {
  log.debug("getBoxes");
  return this.doASAP(function(imap, cb) {
    return imap.getBoxesArray(cb);
  }, function(err, boxes) {
    return callback(err, boxes || []);
  });
};

Account.prototype.imap_refreshBoxes = function(callback) {
  var account;
  log.debug("imap_refreshBoxes");
  account = this;
  return async.series([
    (function(_this) {
      return function(cb) {
        return Mailbox.getBoxes(_this.id, cb);
      };
    })(this), (function(_this) {
      return function(cb) {
        return _this.imap_getBoxes(cb);
      };
    })(this)
  ], function(err, results) {
    var boxToAdd, cozyBox, cozyBoxes, i, imapBoxes, len, toDestroy, toFetch;
    log.debug("refreshBoxes#results", results);
    if (err) {
      return callback(err);
    }
    cozyBoxes = results[0], imapBoxes = results[1];
    toFetch = [];
    toDestroy = [];
    boxToAdd = imapBoxes.filter(function(box) {
      return !_.findWhere(cozyBoxes, {
        path: box.path
      });
    });
    for (i = 0, len = cozyBoxes.length; i < len; i++) {
      cozyBox = cozyBoxes[i];
      if (_.findWhere(imapBoxes, {
        path: cozyBox.path
      })) {
        toFetch.push(cozyBox);
      } else {
        toDestroy.push(cozyBox);
      }
    }
    log.debug("refreshBoxes#results2");
    return async.eachSeries(boxToAdd, function(box, cb) {
      log.debug("refreshBoxes#creating", box.label);
      box.accountID = account.id;
      return Mailbox.create(box, function(err, created) {
        if (err) {
          return cb(err);
        }
        toFetch.push(created);
        return cb(null);
      });
    }, function(err) {
      if (err) {
        return callback(err);
      }
      return callback(null, toFetch, toDestroy);
    });
  });
};

Account.prototype.imap_fetchMails = function(limitByBox, onlyFavorites, callback) {
  var account;
  log.debug("account#imap_fetchMails", limitByBox, onlyFavorites);
  account = this;
  account.setRefreshing(true);
  if (onlyFavorites == null) {
    onlyFavorites = false;
  }
  return this.imap_refreshBoxes(function(err, toFetch, toDestroy) {
    var reporter;
    if (err) {
      account.setRefreshing(false);
    }
    if (err) {
      return callback(err);
    }
    if (onlyFavorites) {
      toFetch = toFetch.filter(function(box) {
        var ref;
        return ref = box.id, indexOf.call(account.favorites, ref) >= 0;
      });
    }
    toFetch = toFetch.filter(function(box) {
      return box.isSelectable();
    });
    log.info("FETCHING ACCOUNT " + account.label + " : " + toFetch.length + " BOXES");
    log.info("   ", toDestroy.length, "BOXES TO DESTROY");
    reporter = ImapReporter.accountFetch(account, toFetch.length + 1);
    toFetch.sort(function(a, b) {
      if (a.label === 'INBOX') {
        return -1;
      } else {
        return 1;
      }
    });
    return async.eachSeries(toFetch, function(box, cb) {
      return box.imap_fetchMails(limitByBox, function(err) {
        var ref;
        if (err && -1 === ((ref = err.message) != null ? ref.indexOf("Mailbox doesn't exist") : void 0)) {
          reporter.onError(err);
        }
        reporter.addProgress(1);
        return cb(null);
      });
    }, function(err) {
      if (err) {
        account.setRefreshing(false);
      }
      if (err) {
        return callback(err);
      }
      log.debug("account#imap_fetchMails#DONE");
      return async.eachSeries(toDestroy, function(box, cb) {
        return box.destroyAndRemoveAllMessages(cb);
      }, function(err) {
        account.setRefreshing(false);
        reporter.onDone();
        return callback(null);
      });
    });
  });
};

Account.prototype.imap_fetchMailsTwoSteps = function(callback) {
  log.debug("account#imap_fetchMails2Steps");
  return this.imap_fetchMails(100, true, (function(_this) {
    return function(err) {
      if (err) {
        return callback(err);
      }
      return _this.imap_fetchMails(null, false, function(err) {
        if (err) {
          return callback(err);
        }
        return callback(null);
      });
    };
  })(this));
};

Account.prototype.imap_createMail = function(box, message, callback) {
  var mailbuilder;
  mailbuilder = new Compiler(message).compile();
  return mailbuilder.build((function(_this) {
    return function(err, buffer) {
      if (err) {
        return callback(err);
      }
      return _this.doASAP(function(imap, cb) {
        return imap.append(buffer, {
          mailbox: box.path,
          flags: message.flags
        }, cb);
      }, function(err, uid) {
        if (err) {
          return callback(err);
        }
        return callback(null, uid);
      });
    };
  })(this));
};

Account.prototype.imap_scanBoxesForSpecialUse = function(boxes, callback) {
  var box, boxAttributes, changes, i, id, inboxMailbox, j, len, len1, priorities, ref, type, useRFC6154;
  useRFC6154 = false;
  inboxMailbox = null;
  boxAttributes = Object.keys(Mailbox.RFC6154);
  changes = {};
  boxes.map(function(box) {
    var attribute, i, len, type;
    type = box.RFC6154use();
    if (box.isInbox()) {
      inboxMailbox = box.id;
    } else if (type) {
      if (!useRFC6154) {
        useRFC6154 = true;
        for (i = 0, len = boxAttributes.length; i < len; i++) {
          attribute = boxAttributes[i];
          changes[attribute] = null;
        }
      }
      log.debug('found', type);
      changes[type] = box.id;
    } else if (!useRFC6154 && (type = box.guessUse())) {
      log.debug('found', type, 'guess');
      changes[type] = box.id;
    }
    return box;
  });
  priorities = ['inboxMailbox', 'allMailbox', 'sentMailbox', 'draftMailbox'];
  changes.inboxMailbox = inboxMailbox;
  changes.favorites = [];
  for (i = 0, len = priorities.length; i < len; i++) {
    type = priorities[i];
    id = changes[type];
    if (id) {
      changes.favorites.push(id);
    }
  }
  for (j = 0, len1 = boxes.length; j < len1; j++) {
    box = boxes[j];
    if (changes.favorites.length < 4) {
      if ((ref = box.id, indexOf.call(changes.favorites, ref) < 0) && box.isSelectable()) {
        changes.favorites.push(box.id);
      }
    }
  }
  return this.updateAttributes(changes, callback);
};

Account.prototype.sendMessage = function(message, callback) {
  var transport;
  if (this.isTest()) {
    return callback(null, {
      messageId: 66
    });
  }
  transport = nodemailer.createTransport({
    port: this.smtpPort,
    host: this.smtpServer,
    secure: this.smtpSSL,
    ignoreTLS: !this.smtpTLS,
    tls: {
      rejectUnauthorized: false
    },
    auth: {
      user: this.login,
      pass: this.password
    }
  });
  return transport.sendMail(message, callback);
};

Account.prototype.testSMTPConnection = function(callback) {
  var auth, connection, reject, timeout;
  if (this.isTest()) {
    return callback(null);
  }
  reject = _.once(callback);
  connection = new SMTPConnection({
    port: this.smtpPort,
    host: this.smtpServer,
    secure: this.smtpSSL,
    ignoreTLS: !this.smtpTLS,
    tls: {
      rejectUnauthorized: false
    }
  });
  auth = {
    user: this.login,
    pass: this.password
  };
  connection.once('error', function(err) {
    log.warn("SMTP CONNECTION ERROR", err);
    return reject(new AccountConfigError('smtpServer'));
  });
  timeout = setTimeout(function() {
    reject(new AccountConfigError('smtpPort'));
    return connection.close();
  }, 10000);
  return connection.connect(function(err) {
    if (err) {
      return reject(new AccountConfigError('smtpServer'));
    }
    clearTimeout(timeout);
    return connection.login(auth, function(err) {
      if (err) {
        reject(new AccountConfigError('auth'));
      } else {
        callback(null);
      }
      return connection.close();
    });
  });
};
